{"version":3,"sources":["../../src/index.js","../../src/TransportWebUSB.js","../../src/hid-framing.js","../../src/webusb.js"],"names":["devices","blue","id","productName","productIdMM","legacyUsbProductId","usbOnly","memorySize","blockSize","nanoS","nanoX","bluetoothSpec","serviceUuid","notifyUuid","writeUuid","devicesList","Object","ledgerUSBVendorId","identifyUSBProductId","usbProductId","legacy","d","mm","bluetoothServices","serviceUuidToInfos","deviceModel","i","spec","constructor","device","channel","Math","packetSize","interfaceNumber","e","apdu","a","log","framing","hidFraming","blocks","result","r","buffer","Buffer","acc","this","releaseInterface","requestLedgerDevice","TransportWebUSB","getLedgerDevices","iface","alternates","transport","onDisconnect","navigator","isSupported","list","listen","observer","unsubscribed","getFirstLedgerDevice","type","descriptor","error","window","unsubscribe","asUInt16BE","value","b","initialAcc","data","dataLength","sequence","makeBlocks","nbBlocks","head","chunk","reduceResponse","TransportError","chunkData","getReducedResult","ledgerDevices","vendorId","filters","existingDevices","Promise"],"mappings":"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","file":"static/js/19.ad9e3b16.chunk.js","sourcesContent":["// @flow\n\n/**\n * The USB product IDs will be defined as MMII, encoding a model (MM) and an interface bitfield (II)\n *\n ** Model\n * Ledger Nano S : 0x10\n * Ledger Blue : 0x00\n * Ledger Nano X : 0x40\n *\n ** Interface support bitfield\n * Generic HID : 0x01\n * Keyboard HID : 0x02\n * U2F : 0x04\n * CCID : 0x08\n * WebUSB : 0x10\n */\n\nexport const IIGenericHID = 0x01;\nexport const IIKeyboardHID = 0x02;\nexport const IIU2F = 0x04;\nexport const IICCID = 0x08;\nexport const IIWebUSB = 0x10;\n\nconst devices = {\n  blue: {\n    id: \"blue\",\n    productName: \"Ledger Blue\",\n    productIdMM: 0x00,\n    legacyUsbProductId: 0x0000,\n    usbOnly: true,\n    memorySize: 480 * 1024,\n    blockSize: 4 * 1024,\n  },\n  nanoS: {\n    id: \"nanoS\",\n    productName: \"Ledger Nano S\",\n    productIdMM: 0x10,\n    legacyUsbProductId: 0x0001,\n    usbOnly: true,\n    memorySize: 320 * 1024,\n    blockSize: 4 * 1024,\n  },\n  nanoX: {\n    id: \"nanoX\",\n    productName: \"Ledger Nano X\",\n    productIdMM: 0x40,\n    legacyUsbProductId: 0x0004,\n    usbOnly: false,\n    memorySize: 2 * 1024 * 1024,\n    blockSize: 4 * 1024,\n    bluetoothSpec: [\n      {\n        // this is the legacy one (prototype version). we will eventually drop it.\n        serviceUuid: \"d973f2e0-b19e-11e2-9e96-0800200c9a66\",\n        notifyUuid: \"d973f2e1-b19e-11e2-9e96-0800200c9a66\",\n        writeUuid: \"d973f2e2-b19e-11e2-9e96-0800200c9a66\",\n      },\n      {\n        serviceUuid: \"13d63400-2c97-0004-0000-4c6564676572\",\n        notifyUuid: \"13d63400-2c97-0004-0001-4c6564676572\",\n        writeUuid: \"13d63400-2c97-0004-0002-4c6564676572\",\n      },\n    ],\n  },\n};\n\nconst productMap = {\n  Blue: \"blue\",\n  \"Nano S\": \"nanoS\",\n  \"Nano X\": \"nanoX\",\n};\n\n// $FlowFixMe\nconst devicesList: DeviceModel[] = Object.values(devices);\n\n/**\n *\n */\nexport const ledgerUSBVendorId = 0x2c97;\n\n/**\n *\n */\nexport const getDeviceModel = (id: DeviceModelId): DeviceModel => {\n  const info = devices[id];\n  if (!info) throw new Error(\"device '\" + id + \"' does not exist\");\n  return info;\n};\n\n/**\n *\n */\nexport const identifyUSBProductId = (usbProductId: number): ?DeviceModel => {\n  const legacy = devicesList.find((d) => d.legacyUsbProductId === usbProductId);\n  if (legacy) return legacy;\n\n  const mm = usbProductId >> 8;\n  const deviceModel = devicesList.find((d) => d.productIdMM === mm);\n  return deviceModel;\n};\n\nexport const identifyProductName = (productName: string): ?DeviceModel => {\n  const productId = productMap[productName];\n  const deviceModel = devicesList.find((d) => d.id === productId);\n\n  return deviceModel;\n};\n\nconst bluetoothServices: string[] = [];\nconst serviceUuidToInfos: {\n  [_: string]: BluetoothInfos,\n} = {};\n\nfor (let id in devices) {\n  const deviceModel = devices[id];\n  const { bluetoothSpec } = deviceModel;\n  if (bluetoothSpec) {\n    for (let i = 0; i < bluetoothSpec.length; i++) {\n      const spec = bluetoothSpec[i];\n      bluetoothServices.push(spec.serviceUuid);\n      serviceUuidToInfos[spec.serviceUuid] = serviceUuidToInfos[\n        spec.serviceUuid.replace(/-/g, \"\")\n      ] = { deviceModel, ...spec };\n    }\n  }\n}\n\n/**\n *\n */\nexport const getBluetoothServiceUuids = () => bluetoothServices;\n\n/**\n *\n */\nexport const getInfosForServiceUuid = (uuid: string): ?BluetoothInfos =>\n  serviceUuidToInfos[uuid.toLowerCase()];\n\n/**\n *\n */\nexport type DeviceModelId = $Keys<typeof devices>;\n\n/**\n *\n */\nexport type DeviceModel = {\n  id: DeviceModelId,\n  productName: string,\n  productIdMM: number,\n  legacyUsbProductId: number,\n  usbOnly: boolean,\n  memorySize: number,\n  blockSize: number,\n  bluetoothSpec?: Array<{\n    serviceUuid: string,\n    writeUuid: string,\n    notifyUuid: string,\n  }>,\n};\n\n/**\n *\n */\nexport type BluetoothInfos = {\n  deviceModel: DeviceModel,\n  serviceUuid: string,\n  writeUuid: string,\n  notifyUuid: string,\n};\n","//@flow\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription,\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { log } from \"@ledgerhq/logs\";\nimport {\n  TransportOpenUserCancelled,\n  TransportInterfaceNotAvailable,\n  TransportWebUSBGestureRequired,\n  DisconnectedDeviceDuringOperation,\n  DisconnectedDevice,\n} from \"@ledgerhq/errors\";\nimport {\n  getLedgerDevices,\n  getFirstLedgerDevice,\n  requestLedgerDevice,\n  isSupported,\n} from \"./webusb\";\n\nconst configurationValue = 1;\nconst endpointNumber = 3;\n\n/**\n * WebUSB Transport implementation\n * @example\n * import TransportWebUSB from \"@ledgerhq/hw-transport-webusb\";\n * ...\n * TransportWebUSB.create().then(transport => ...)\n */\nexport default class TransportWebUSB extends Transport<USBDevice> {\n  device: USBDevice;\n  deviceModel: ?DeviceModel;\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  interfaceNumber: number;\n\n  constructor(device: USBDevice, interfaceNumber: number) {\n    super();\n    this.device = device;\n    this.interfaceNumber = interfaceNumber;\n    this.deviceModel = identifyUSBProductId(device.productId);\n  }\n\n  /**\n   * Check if WebUSB transport is supported.\n   */\n  static isSupported = isSupported;\n\n  /**\n   * List the WebUSB devices that was previously authorized by the user.\n   */\n  static list = getLedgerDevices;\n\n  /**\n   * Actively listen to WebUSB devices and emit ONE device\n   * that was either accepted before, if not it will trigger the native permission UI.\n   *\n   * Important: it must be called in the context of a UI click!\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<USBDevice>>\n  ): Subscription => {\n    let unsubscribed = false;\n    getFirstLedgerDevice().then(\n      (device) => {\n        if (!unsubscribed) {\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor: device, deviceModel });\n          observer.complete();\n        }\n      },\n      (error) => {\n        if (\n          window.DOMException &&\n          error instanceof window.DOMException &&\n          error.code === 18\n        ) {\n          observer.error(new TransportWebUSBGestureRequired(error.message));\n        } else {\n          observer.error(new TransportOpenUserCancelled(error.message));\n        }\n      }\n    );\n    function unsubscribe() {\n      unsubscribed = true;\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * Similar to create() except it will always display the device permission (even if some devices are already accepted).\n   */\n  static async request() {\n    const device = await requestLedgerDevice();\n    return TransportWebUSB.open(device);\n  }\n\n  /**\n   * Similar to create() except it will never display the device permission (it returns a Promise<?Transport>, null if it fails to find a device).\n   */\n  static async openConnected() {\n    const devices = await getLedgerDevices();\n    if (devices.length === 0) return null;\n    return TransportWebUSB.open(devices[0]);\n  }\n\n  /**\n   * Create a Ledger transport with a USBDevice\n   */\n  static async open(device: USBDevice) {\n    await device.open();\n    if (device.configuration === null) {\n      await device.selectConfiguration(configurationValue);\n    }\n    await device.reset();\n    const iface = device.configurations[0].interfaces.find(({ alternates }) =>\n      alternates.some((a) => a.interfaceClass === 255)\n    );\n    if (!iface) {\n      throw new TransportInterfaceNotAvailable(\n        \"No WebUSB interface found for your Ledger device. Please upgrade firmware or contact techsupport.\"\n      );\n    }\n    const interfaceNumber = iface.interfaceNumber;\n    try {\n      await device.claimInterface(interfaceNumber);\n    } catch (e) {\n      await device.close();\n      throw new TransportInterfaceNotAvailable(e.message);\n    }\n    const transport = new TransportWebUSB(device, interfaceNumber);\n    const onDisconnect = (e) => {\n      if (device === e.device) {\n        // $FlowFixMe\n        navigator.usb.removeEventListener(\"disconnect\", onDisconnect);\n        transport._emitDisconnect(new DisconnectedDevice());\n      }\n    };\n    // $FlowFixMe\n    navigator.usb.addEventListener(\"disconnect\", onDisconnect);\n    return transport;\n  }\n\n  _disconnectEmitted = false;\n  _emitDisconnect = (e: Error) => {\n    if (this._disconnectEmitted) return;\n    this._disconnectEmitted = true;\n    this.emit(\"disconnect\", e);\n  };\n\n  /**\n   * Release the transport device\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    await this.device.releaseInterface(this.interfaceNumber);\n    await this.device.reset();\n    await this.device.close();\n  }\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { channel, packetSize } = this;\n      log(\"apdu\", \"=> \" + apdu.toString(\"hex\"));\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.device.transferOut(endpointNumber, blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const r = await this.device.transferIn(endpointNumber, packetSize);\n        const buffer = Buffer.from(r.data.buffer);\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      log(\"apdu\", \"<= \" + result.toString(\"hex\"));\n      return result;\n    }).catch((e) => {\n      if (e && e.message && e.message.includes(\"disconnected\")) {\n        this._emitDisconnect(e);\n        throw new DisconnectedDeviceDuringOperation(e.message);\n      }\n      throw e;\n    });\n\n  setScrambleKey() {}\n}\n","// @flow\n\nimport { TransportError } from \"@ledgerhq/errors\";\n\nexport type ResponseAcc = ?{\n  data: Buffer,\n  dataLength: number,\n  sequence: number,\n};\n\nconst Tag = 0x05;\n\nfunction asUInt16BE(value) {\n  const b = Buffer.alloc(2);\n  b.writeUInt16BE(value, 0);\n  return b;\n}\n\nconst initialAcc = {\n  data: Buffer.alloc(0),\n  dataLength: 0,\n  sequence: 0,\n};\n\n/**\n *\n */\nconst createHIDframing = (channel: number, packetSize: number) => {\n  return {\n    makeBlocks(apdu: Buffer): Buffer[] {\n      let data = Buffer.concat([asUInt16BE(apdu.length), apdu]);\n      const blockSize = packetSize - 5;\n      const nbBlocks = Math.ceil(data.length / blockSize);\n      data = Buffer.concat([\n        data, // fill data with padding\n        Buffer.alloc(nbBlocks * blockSize - data.length + 1).fill(0),\n      ]);\n\n      const blocks = [];\n      for (let i = 0; i < nbBlocks; i++) {\n        const head = Buffer.alloc(5);\n        head.writeUInt16BE(channel, 0);\n        head.writeUInt8(Tag, 2);\n        head.writeUInt16BE(i, 3);\n        const chunk = data.slice(i * blockSize, (i + 1) * blockSize);\n        blocks.push(Buffer.concat([head, chunk]));\n      }\n      return blocks;\n    },\n\n    reduceResponse(acc: ResponseAcc, chunk: Buffer): ResponseAcc {\n      let { data, dataLength, sequence } = acc || initialAcc;\n\n      if (chunk.readUInt16BE(0) !== channel) {\n        throw new TransportError(\"Invalid channel\", \"InvalidChannel\");\n      }\n      if (chunk.readUInt8(2) !== Tag) {\n        throw new TransportError(\"Invalid tag\", \"InvalidTag\");\n      }\n      if (chunk.readUInt16BE(3) !== sequence) {\n        throw new TransportError(\"Invalid sequence\", \"InvalidSequence\");\n      }\n\n      if (!acc) {\n        dataLength = chunk.readUInt16BE(5);\n      }\n      sequence++;\n      const chunkData = chunk.slice(acc ? 5 : 7);\n      data = Buffer.concat([data, chunkData]);\n      if (data.length > dataLength) {\n        data = data.slice(0, dataLength);\n      }\n\n      return {\n        data,\n        dataLength,\n        sequence,\n      };\n    },\n\n    getReducedResult(acc: ResponseAcc): ?Buffer {\n      if (acc && acc.dataLength === acc.data.length) {\n        return acc.data;\n      }\n    },\n  };\n};\n\nexport default createHIDframing;\n","// @flow\nimport { ledgerUSBVendorId } from \"@ledgerhq/devices\";\n\nconst ledgerDevices = [{ vendorId: ledgerUSBVendorId }];\n\nexport async function requestLedgerDevice(): Promise<USBDevice> {\n  // $FlowFixMe\n  const device = await navigator.usb.requestDevice({ filters: ledgerDevices });\n  return device;\n}\n\nexport async function getLedgerDevices(): Promise<USBDevice[]> {\n  // $FlowFixMe\n  const devices = await navigator.usb.getDevices();\n  return devices.filter((d) => d.vendorId === ledgerUSBVendorId);\n}\n\nexport async function getFirstLedgerDevice(): Promise<USBDevice> {\n  const existingDevices = await getLedgerDevices();\n  if (existingDevices.length > 0) return existingDevices[0];\n  return requestLedgerDevice();\n}\n\nexport const isSupported = (): Promise<boolean> =>\n  Promise.resolve(\n    !!navigator &&\n      // $FlowFixMe\n      !!navigator.usb &&\n      typeof navigator.usb.getDevices === \"function\"\n  );\n"],"sourceRoot":""}